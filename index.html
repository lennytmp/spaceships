<html ng-app="gameApp">
<head>
  <title>Spaceships Prototype</title>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" ></script>
  <link rel="stylesheet" href="http://getbootstrap.com/2.0.4/assets/css/bootstrap-responsive.css">
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
  <style>
    .progressFrame {
      height: 14pt;
      margin: 2pt 0;
      width: 80pt;
      border: 1px solid;
    }
    .progressFill {
      height: 14pt;
      white-space: nowrap;
      text-align: center;
    }
    .damaged {
      color: red;
      font-weight: bold;
    }
    .energyBar {
      display:inline-block;
      margin: 4pt 1pt 0pt 0pt;
      width: 25pt;
      height: 12pt;
      border: 1px solid cyan;
    }
    .energyBar.filled {
      border: 1px solid cyan;
      background-color: cyan;
    }
    select, option {
      font-size: 11pt;
    }
  </style>
  <script>
  var GARAGE_MODE = 0;
  var FIGHT_MODE = 1;
  var HP_UNIT = 10;
  var MAX_FIGHT_TICKS = 30;
  var FIGHT_RESOLUTION_MS = 100;
  var GOD_MODE = true;
  var SHIELD_CLASS = 0;
  var WEAPON_CLASS = 1;
  var ENERGY_PROVIDER_CLASS = 2;

  var mode = GARAGE_MODE;


  function Ship() {
    this.rooms = [];
    this.level = 0;
    this.maxRooms = 2;
    this.resources = {"minerals": 100, "gas": 100};
    this.maxRoomId = 0;
    this.isMine = false;
    this.rating = 90;
    this.newRoomCosts = {
      'Laser': {'minerals': 200, 'gas': 200},
      'Minigun': {'minerals': 400, 'gas': 300},
      'Reactor': {'minerals': 10, 'gas': 300},
      'Shield': {'minerals': 800, 'gas': 800},
    }
    this.upgrade = new Upgrade(100, 0, {maxRooms: 1});
    this.freeEnergy = 0;
  }

  Ship.prototype.decEnergyForRoom = function(roomId, vol) {
    var room = this.rooms[roomId];
    if (!room || room.energy < vol) {
      return;
    }
    room.energy -= vol;
    room.updateProperties(this);
    this.freeEnergy += vol;
  }

  Ship.prototype.incEnergyForRoom = function(roomId, vol) {
    var room = this.rooms[roomId];
    var room = this.rooms[roomId];
    if (!room || room.hp <= 0 || this.freeEnergy < vol || room.energy + vol > room.energyDemand) {
      return;
    }
    this.freeEnergy -= vol;
    if (room.energy == 0) {
      resetTimers(room);
    }
    room.energy += vol;
    room.updateProperties(this);
  }

  Ship.prototype.doUpgrade =  function(upgrade, entity) {
    if (!upgrade.cost || !this.haveEnoughResources(upgrade.cost)) {
      return false;
    }
    this.chargeCost(upgrade.cost);
    for (key in upgrade.improvements) {
      entity[key] += upgrade.improvements[key];
    }
    if (entity.hp !== undefined) {
      entity.hp = entity.maxHp;
    }
    entity.level++;
    if (entity.upgradesPerLevel === undefined) {
      for (var resType in upgrade.cost) {
        upgrade.cost[resType] *= 2;
      }
    } else {
      var nextUpgrade = entity.upgradesPerLevel[entity.level];
      if (nextUpgrade !== undefined) {
        entity.upgrade = JSON.parse(JSON.stringify(nextUpgrade));
      } else {
        entity.upgrade = undefined;
      }
    }
    return true;
  }

  Ship.prototype.chargeCost = function(cost) {
      for (var resType in cost) {
        this.resources[resType] -= cost[resType];
      }
  }

  Ship.prototype.getIvenstmentOptions = function() {
    var result = [];
    var me = this;
    if (this.upgrade !== undefined && this.haveEnoughResources(this.upgrade.cost)) {
      result.push({'cost': this.upgrade.cost, 'apply': function() {
            me.doUpgrade(me.upgrade, me);
      }});
    }
    for (let title in this.newRoomCosts) {
      let cost = this.newRoomCosts[title];
      if (this.haveEnoughResources(cost)) {
          result.push({'cost': cost, 'apply': function() {
                  me.buyRoom(title);
              }
          });
      }
    }
    for (let id in this.rooms) {
      let room = this.rooms[id];
      if (room.upgrade !== undefined && this.haveEnoughResources(room.upgrade.cost)) {
        result.push({'cost': room.upgrade.cost, 'apply': function() {
                me.doUpgrade(room.upgrade, room);
        }});
      }
    }
    return result;
  }


  function Upgrade(minerals, gas, improvements) {
    this.cost = {"minerals": minerals, "gas": gas};
    this.improvements = improvements;
  }

  function LaserRoom() {
    this.title = "Laser";
    this.type = WEAPON_CLASS;
    this.hp = HP_UNIT;
    this.maxHp = this.hp;
    this.maxDamage = HP_UNIT;
    this.level = 0;
    this.maxReloadRate = 5;
    this.energyDemand = 3;
    this.upgradesPerLevel = [
      new Upgrade(100, 100, {maxReloadRate: 1}),
      new Upgrade(300, 300, {maxHp: HP_UNIT}),
      new Upgrade(600, 150, {maxReloadRate: 1}),
    ];
    this.upgrade = this.upgradesPerLevel[this.level];

    // Fight specific
    this.energy = 0;
    this.damage = 0;
    this.reloadRate = 0;
    this.targetId = 0;
    this.lastProgressUpdateAt = 0;
    this.progress = 0;
  }
  LaserRoom.prototype.updateProperties = function(ship) {
    if (this.hp == 0) {
      ship.freeEnergy += this.energy;
      this.energy = 0;
    }
    this.reloadRate = Math.round(this.maxReloadRate*this.energy/this.energyDemand);
    this.damage = Math.round(this.maxDamage*(this.hp/this.maxHp));
  }
  function MinigunRoom() {
    this.title = "Minigun";
    this.type = WEAPON_CLASS;
    this.hp = HP_UNIT;
    this.maxHp = this.hp;
    this.maxDamage = 2;
    this.level = 0;
    this.maxReloadRate = 10;
    this.energyDemand = 3;
    this.upgradesPerLevel = [
      new Upgrade(100, 100, {maxDamage: 1}),
      new Upgrade(300, 300, {maxHp: HP_UNIT}),
      new Upgrade(600, 150, {maxDamage: 1}),
    ];
    this.upgrade = this.upgradesPerLevel[this.level];

    // Fight specific
    this.energy = 0;
    this.damage = 0;
    this.reloadRate = 0;
    this.targetId = 0;
    this.lastProgressUpdateAt = 0;
    this.progress = 0;
  }
  MinigunRoom.prototype.updateProperties = function(ship) {
    if (this.hp == 0) {
      ship.freeEnergy += this.energy;
      this.energy = 0;
    }
    this.reloadRate = Math.round(this.maxReloadRate*this.energy/this.energyDemand);
    this.damage = Math.round(this.maxDamage*(this.hp/this.maxHp));
  }

  function ShieldRoom() {
    this.title = "Shield";
    this.type = SHIELD_CLASS;
    this.hp = HP_UNIT;
    this.maxHp = this.hp;
    this.maxMaxShield = HP_UNIT;
    this.level = 0;
    this.maxReloadRate = 5;
    this.energyDemand = 3;
    this.upgradesPerLevel = [
      new Upgrade(100, 1000, {maxMaxShield: 1}),
      new Upgrade(200, 2000, {maxReloadRate: 1}),
      new Upgrade(500, 3500, {maxHp: HP_UNIT}),
    ];
    this.upgrade = this.upgradesPerLevel[this.level];

    // Fight specific
    this.energy = 0;
    this.maxShield = 0;
    this.shield = 0;
    this.curShield = 0;
    this.reloadRate = 0;
    this.lastProgressUpdateAt = 0;
    this.progress = 0;
  }
  ShieldRoom.prototype.updateProperties = function(ship) {
    if (this.hp == 0) {
      ship.freeEnergy += this.energy;
      this.energy = 0;
      this.curShield = 0;
    }
    this.reloadTime = (50/this.maxReloadRate)*1000;
    this.reloadTime *= this.energyDemand / this.energy;
    this.reloadRate = Math.round(50*1000/this.reloadTime);
    this.maxShield = Math.round(this.maxMaxShield*(this.hp/this.maxHp));
    if (this.curShield > this.maxShield) {
      this.curShield = this.maxShield;
    }
  }

  function ReactorRoom() {
    this.hp = HP_UNIT;
    this.maxHp = this.hp;
    this.title = "Reactor";
    this.type = ENERGY_PROVIDER_CLASS;
    this.level = 0;
    this.maxEnergySupply = 3;
    this.upgradesPerLevel = [
      new Upgrade(100, 200, {maxEnergySupply: 1}),
      new Upgrade(300, 150, {maxHp: HP_UNIT}),
      new Upgrade(200, 400, {maxEnergySupply: 1}),
      new Upgrade(400, 800, {maxEnergySupply: 1}),
      new Upgrade(1000, 300, {maxHp: HP_UNIT}),
    ];
    this.upgrade = this.upgradesPerLevel[this.level];

    // Fight specific
    this.energySupply = 0;
  }
  ReactorRoom.prototype.updateProperties = function(ship) {
    var before = this.energySupply;
    this.energySupply = Math.round(this.maxEnergySupply*(this.hp/this.maxHp));
    ship.freeEnergy += this.energySupply - before;
  }

  Ship.prototype.buyRoom = function(title) {
    if (!this.newRoomCosts[title]) {
      return false;
    }
    var cost = this.newRoomCosts[title];
    if (!this.haveEnoughResources(cost)) {
      return false;
    }
    this.chargeCost(cost);
    var r;
    switch (title) {
      case 'Minigun':
        r = new MinigunRoom();
        break;
      case 'Laser':
        r = new LaserRoom();
        break;
      case 'Reactor':
        r = new ReactorRoom();
        break;
      case 'Shield':
        r = new ShieldRoom();
        break;
    }
    if (r === undefined) {
      return false;
    }
    this.addRoom(r);
    return true;
  }

  Ship.prototype.addRoom = function(room) {
    this.rooms[this.maxRoomId] = room;
    this.maxRoomId++;
  }

  Ship.prototype.haveEnoughResources = function(cost) {
      if (GOD_MODE && this.isMine) {
        return true;
      }
      for (var resType in cost) {
        if (this.resources[resType] < cost[resType]) {
          return false;
        }
      }
      return true;
  }

  function recoverHp(myShip, mode) {
    if (mode != GARAGE_MODE) {
      return;
    }
    var recovered = false;
    for (var k in myShip.rooms) {
      var room = myShip.rooms[k];
      if (room.hp < room.maxHp) {
        room.hp += 1;
        if (room.hp > room.maxHp) {
          room.hp = room.maxHp;
        }
        break;
      }
    }
  }

  function resetTimers(room) {
    var now = Date.now();
    if (room.lastProgressUpdateAt !== undefined) {
      room.lastProgressUpdateAt = now;
    }
  }

  Ship.prototype.initBeforeFight = function() {
    this.freeEnergy = 0;
    for (id in this.rooms) {
      var room = this.rooms[id];
      resetTimers(room);
      if (room.shield !== undefined) {
        room.maxShield = room.maxMaxShield;
        room.shield = room.maxShield;
      }
      if (room.energySupply !== undefined) {
        room.energySupply = room.maxEnergySupply;
        this.freeEnergy += room.energySupply;
      }
      if (room.energyDemand !== undefined) {
        room.energy = 0;
      }
    }
  }

  Ship.prototype.spendFreeEnergy = function() {
    var totalEnergyDemand = 0;
    for (id in this.rooms) {
      var room = this.rooms[id];
      if (room.hp == 0) {
        continue;
      }
      if (room.energyDemand !== undefined) {
        totalEnergyDemand += room.energyDemand - room.energy;
      }
    }
    while (this.freeEnergy > 0 && totalEnergyDemand > 0) {
      for (id in this.rooms) {
        var room = this.rooms[id];
        if (room.hp == 0 || room.energyDemand === undefined || room.energy >= room.energyDemand) {
          continue;
        }
        room.energy++;
        this.freeEnergy--;
        totalEnergyDemand--;
        if (this.freeEnergy == 0 || totalEnergyDemand == 0) {
          break;
        }
      }
    }
  }


  Ship.prototype.redistributeEnergy = function() {
    while (this.freeEnergy < 0) {
      for (id in this.rooms) {
        var room = this.rooms[id];
        if (room.energyDemand !== undefined && room.energy > 0) {
          room.energy--;
          this.freeEnergy++;
        }
      }
    }
    if (!this.isMine) {
      this.spendFreeEnergy();
    }
    for (id in this.rooms) {
      var room = this.rooms[id];
      if (room.updateProperties !== undefined) {
        room.updateProperties(this);
      }
    }
  }


  function getShipTargetsDamage(ship) {
    var myDamage = {};
    var now = Date.now();
    for (var k in ship.rooms) {
      var room = ship.rooms[k];
      if (room.type == WEAPON_CLASS) {
        room.progress += (now - room.lastProgressUpdateAt)*2*room.reloadRate/1000;
        room.lastProgressUpdateAt = now;
        if (room.progress < 100) {
          continue;
        }
        room.progress = 0;
        if (room.hp <= 0) {
          continue;
        }
        if (myDamage[room.targetId] === undefined) {
          myDamage[room.targetId] = 0;
        }
        myDamage[room.targetId] += room.damage;
      }
    }
    return myDamage;
  }

  function checkDead(ship) {
    for (var k in ship.rooms) {
      if (ship.rooms[k].hp > 0) {
        return false;
      }
    }
    return true;
  }

  function setNewTargetsIfNeeded(ship, enemy) {
    var newTarget;
    for (var k in enemy.rooms) {
      if (enemy.rooms[k].hp > 0) {
        newTarget = k;
        break;
      }
    }
    for (var k in ship.rooms) {
      var room = ship.rooms[k];
      if (room.type == WEAPON_CLASS) {
        if (enemy.rooms[room.targetId].hp <= 0) {
          room.targetId = newTarget;
        }
      }
    }
  }

  function applyDamage(ship, damage) {
    var myDamage = {};
    var now = Date.now();
    var totalShield = 0;
    var healthyShieldRooms = [];
    for (var id in ship.rooms) {
      var room = ship.rooms[id];
      if (room.type == SHIELD_CLASS) {
        if (room.hp <= 0) {
          continue;
        }
        healthyShieldRooms.push(room);
        room.progress += (now - room.lastProgressUpdateAt)*2*room.reloadRate/1000;
        room.lastProgressUpdateAt = now;
        if (room.progress >= 100) {
          room.progress = 0;
          room.shield = Math.min(room.shield + 1, room.maxShield);
        }
        totalShield += room.shield;
      }
    }
    var totalShieldBefore = totalShield;
    for (var id in damage) {
      var target = ship.rooms[id];
      var dmg = Math.round(damage[id]);
      if (totalShield > 0) {
        var blockedByShield = Math.min(totalShield, dmg);
        totalShield -= blockedByShield;
        dmg -= blockedByShield;
      }
      target.hp -= dmg;
      if (target.hp < 0) {
        target.hp = 0;
      }
      if (target.updateProperties !== undefined) {
        target.updateProperties(ship);
      }
    }
    var deltaShield = totalShieldBefore - totalShield;
    while (deltaShield > 0) {
      var i = Math.round(Math.random()*(healthyShieldRooms.length - 1));
      var shieldRoom = healthyShieldRooms[i];
      if (shieldRoom.shield > 0) {
        healthyShieldRooms[i].shield--;
        deltaShield--;
      } else {
        healthyShieldRooms.splice(i);
      }
    }
  }


  function progressFight(myShip, enemy, fightStatus, callback) {
    if (fightStatus.mySurrender) {
      alert("You lost!");
      myShip.rating = Math.round(myShip.rating*0.33);
      for (var id in myShip.rooms) {
        myShip.rooms[id].hp = 0;
      }
      callback();
      return;
    }
    if (fightStatus.now > fightStatus.end) {
      alert("Draw due to timeout!");
      myShip.rating = Math.round(myShip.rating*0.4);
      callback();
      return;
    }
    enemy.redistributeEnergy();
    myShip.redistributeEnergy();
    // TODO: This is biased towards the damage from my ship, it shouldn't be.
    // TODO: If the tab is not active - the timing can go wrong.
    enemyDamage = getShipTargetsDamage(myShip);
    myDamage = getShipTargetsDamage(enemy);
    applyDamage(enemy, enemyDamage);
    applyDamage(myShip, myDamage);
    if (checkDead(enemy)) {
      alert("You won!");
      for (type in enemy.resources) {
        myShip.resources[type] += enemy.resources[type];
      }
      myShip.rating *= 2;
      callback();
      return;
    }
    if (checkDead(myShip)) {
      alert("You lost!");
      myShip.rating = Math.round(myShip.rating*0.33);
      callback();
      return;
    }
    setNewTargetsIfNeeded(myShip, enemy);
    setNewTargetsIfNeeded(enemy, myShip);

    setTimeout(function() {
        fightStatus.now = Date.now();
        progressFight(myShip, enemy, fightStatus, callback);
      }, FIGHT_RESOLUTION_MS);
  }

  // Kudos to https://stackoverflow.com/a/49434653
  function rand_bm(min, max, skew) {
      var u = 0, v = 0;
      while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
      while(v === 0) v = Math.random();
      let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

      num = num / 10.0 + 0.5; // Translate to 0 -> 1
      if (num > 1 || num < 0) num = randn_bm(min, max, skew); // resample between 0 and 1 if out of range
      num = Math.pow(num, skew); // Skew
      num *= max - min; // Stretch to fill range
      num += min; // offset to min
      return num;
  }

  function investRandomly(ship, rating) {
    for (resType in ship.resources) {
      ship.resources[resType] = rating;
    }
    let options = ship.getIvenstmentOptions();
    while (options.length > 0) {
        let i = Math.max(0, Math.round(Math.random()*options.length - 1));
        options[i].apply();
        options = ship.getIvenstmentOptions();
    }
    for (resType in ship.resources) {
      ship.resources[resType] = Math.round(rand_bm(40*(ship.level+1), 70*(ship.level+1), 1));
    }
  }

  function FightStatus(lvl) {
    var now = Date.now();
    this.now = now;
    this.start = now;
    this.end = now + MAX_FIGHT_TICKS*1000*(lvl*0.5+1);
    this.mySurrender = false;
  }
  FightStatus.prototype.min = function() {
    var d = (this.end - this.now)/1000;
    return Math.floor(d/60);
  }
  FightStatus.prototype.sec = function() {
    var d = (this.end - this.now)/1000;
    return Math.round(d - this.min()*60);
  }
  </script>
  <script>
  // Angular magic starts here
  var app = angular.module("gameApp", []);
  app.controller("appController",
    function($scope, $timeout) {
      $scope.GARAGE_MODE = GARAGE_MODE;
      $scope.FIGHT_MODE = FIGHT_MODE;
      $scope.SHIELD_CLASS = SHIELD_CLASS;
      $scope.WEAPON_CLASS = WEAPON_CLASS;
      $scope.ENERGY_PROVIDER_CLASS = ENERGY_PROVIDER_CLASS;


      var myShip = new Ship();
      myShip.isMine = true;
      myShip.addRoom(new LaserRoom());
      myShip.addRoom(new ReactorRoom());

      $scope.myShip = myShip;
      $scope.mode = GARAGE_MODE;
      $scope.debug = true;
      $scope.Math = window.Math;

      $scope.surrender = function() {
        $scope.fightStatus.mySurrender = true;
      };

      $scope.fight = function() {
        var enemy = new Ship();
        enemy.addRoom(new LaserRoom());
        enemy.addRoom(new ReactorRoom());
        $scope.enemy = enemy;
        investRandomly(enemy, myShip.rating);
        $scope.fightStatus = new FightStatus(Math.max(myShip.level, enemy.level));
        myShip.initBeforeFight();
        enemy.initBeforeFight();
        myShip.redistributeEnergy();
        myShip.spendFreeEnergy();
        enemy.redistributeEnergy();
        $scope.mode = $scope.FIGHT_MODE;

        setTimeout(function() {
            progressFight(myShip, enemy, $scope.fightStatus, function() {
              $scope.mode = $scope.GARAGE_MODE;
            });
            $scope.$apply();
          }, FIGHT_RESOLUTION_MS);
      };



      setInterval(function() {
          recoverHp(myShip, $scope.mode);
          $scope.$apply();
        }, 1000);
    });
    app.directive("upgrade", function() {
      return {
        restrict: 'E',
        scope: {
          entity: '=',
          ship: '=',
        },
        template: `
          <a ng-if="ship.haveEnoughResources(entity.upgrade.cost)" href="#" ng-click="upgrade(entity)">Upgrade</a>
          <span ng-if="!ship.haveEnoughResources(entity.upgrade.cost)">Upgrade</span>:
          {{entity.upgrade}}
        `,
        controller: ['$scope', function UpgradeController($scope) {
          $scope.upgrade = function(entity) {
            if (entity.upgrade && $scope.ship.doUpgrade(entity.upgrade, entity)) {
              alert("Success");
            } else {
              alert("Could not perform the upgrade!");
            }
          };
        }],
      }
    });
    app.directive("progressBar", function() {
      return {
        restrict: 'E',
        scope: {
          total: '<',
          complete: '<',
          color: '@',
          text: '@',
        },
        template: `
          <div class="progressFrame" style="border-color:{{color}};">
            <div class="progressFill" style="width:{{complete*100/total}}%;background-color:{{color}};">
              {{text}}
            </div>
          </div>
        `,
      }
    });
    app.filter('range', function() {
      return function(input, total) {
        total = parseInt(total);
        for (var i=0; i<total; i++)
          input.push(i);
        return input;
      };
    });
    app.directive("energyControl", function() {
      return {
        restrict: 'E',
        scope: {
          total: '<',
          current: '<',
          roomId: '<',
          ship: '=',
        },
        template: `
          <span ng-repeat="n in [] | range:total" ng-click="change($index)"
            class="energyBar" ng-class="{'filled': current > $index}"></span>
        `,
        controller: ['$scope', function energyControl($scope) {
          $scope.change = function(index) {
            if (index == 0 && $scope.current == 1) {
              $scope.ship.decEnergyForRoom($scope.roomId, 1);
              return;
            }
            if (index < $scope.current) {
              $scope.ship.decEnergyForRoom($scope.roomId, $scope.current - index - 1);
            } else {
              $scope.ship.incEnergyForRoom($scope.roomId, index - $scope.current + 1);
            }
          };
        }],
      }
    });
  </script>
</head>
<body ng-controller="appController">
  <div class="container">
    <div class="row">
      <div class="span8" style="text-align:center;">
        <a ng-if="mode==GARAGE_MODE" id="fight-button" ng-click="fight()" href="#">Fight</a>
        <span ng-if="mode==FIGHT_MODE">The battle will finish in draw in {{fightStatus.min()}}:{{fightStatus.sec()}}</span>
        <a ng-if="mode==FIGHT_MODE" ng-click="surrender()" href="#">Surrender</a>
      </div>
    </div>
    <div class="row">
    <div class="span4">
      <h2>Your ship</h2>
      <div id="you">
        <ul>
          <li ng-if="myShip.freeEnergy > 0 && mode==FIGHT_MODE">
            Free energy:
            <span ng-repeat="n in [] | range:myShip.freeEnergy"
              class="energyBar filled"></span>
          </li>
          <li>Resources: {{ myShip.resources}}</li>
          <li>Level: {{ myShip.level}}</li>
          <li>Max rooms: {{ myShip.maxRooms}}</li>
          <li ng-if="mode==GARAGE_MODE"><upgrade entity="myShip" ship="myShip"/></li>
          <li>Rooms:
            <ul ng-repeat="(roomId, room) in myShip.rooms">
              <li>{{room.title}}-{{roomId}}
                <ul>
                  <!-- progress bars -->
                  <li>
                    <progress-bar complete="room.hp" total="room.maxHp"
                      color="red" text="Hp: {{room.hp}}/{{room.maxHp}}" />
                  </li>
                  <li ng-if="room.type==WEAPON_CLASS && mode==FIGHT_MODE && room.hp > 0 && room.energy > 0">
                    <progress-bar complete="room.progress"
                      total="100" color="#CCCC00"
                      text="Next shot" />
                  </li>
                  <li ng-if="room.type==SHIELD_CLASS && mode==FIGHT_MODE && room.hp > 0 && room.energy > 0">
                    <progress-bar complete="room.progress"
                      total="100" color="#CCCC00"
                      text="Next load" />
                  </li>
                  <li ng-if="room.type==SHIELD_CLASS && mode==FIGHT_MODE && room.hp > 0">
                    <progress-bar complete="room.shield"
                      total="room.maxShield" color="#659EC7"
                      text="Shield: {{room.shield}} / {{room.maxShield}}" />
                  </li>

                  <!-- Everything else -->
                  <li ng-if="room.energyDemand && mode==FIGHT_MODE && room.hp > 0">
                    Energy:
                    <energy-control total="room.energyDemand" room-id="roomId"
                    current="room.energy" ship="myShip" />
                  </li>

                  <li ng-if="room.type==WEAPON_CLASS && mode==GARAGE_MODE">Damage:
                      {{room.maxDamage}}
                  </li>
                  <li ng-if="room.type==WEAPON_CLASS && mode==FIGHT_MODE">Damage:
                    <span ng-class="{damaged: room.damage < room.maxDamage}">
                      {{room.damage}}
                    </span>
                  </li>

                  <li ng-if="room.type==WEAPON_CLASS && mode==GARAGE_MODE">Energy demand: {{room.energyDemand}}</li>
                  <li ng-if="room.type==WEAPON_CLASS && mode==GARAGE_MODE">Reload rate: {{room.maxReloadRate}}</li>
                  <li ng-if="room.type==WEAPON_CLASS && mode==FIGHT_MODE && debug">Reload rate:
                    <span ng-class="{damaged: room.reloadRate < room.maxReloadRate}">
                      {{room.reloadRate}}
                    </span>
                  </li>

                  <li ng-if="room.type==WEAPON_CLASS && mode==FIGHT_MODE">
                    <select ng-model="room.targetId" class="target" ng-init="room.targetId='0'">
                      <option ng-repeat="(enemyRoomId, enemyRoom) in enemy.rooms"
                        value="{{enemyRoomId}}"
                        ng-selected="room.targetId==enemyRoomId">
                        {{enemyRoom.title}}-{{enemyRoomId}}</options>
                    </select>
                  </li>

                  <li ng-if="room.type==SHIELD_CLASS && mode==GARAGE_MODE">Reload rate: {{room.maxReloadRate}}</li>
                  <li ng-if="room.type==SHIELD_CLASS && mode==FIGHT_MODE && debug">Reload rate:
                    <span ng-class="{damaged: room.reloadRate < room.maxReloadRate}">
                      {{room.reloadRate}}
                    </span>
                  </li>
                  <li ng-if="room.type==SHIELD_CLASS && mode==FIGHT_MODE">Energy: {{room.energy}}</li>
                  <li ng-if="room.type==SHIELD_CLASS && mode==FIGHT_MODE">Energy demand: {{room.energyDemand}}</li>
                  <li ng-if="room.type==SHIELD_CLASS && mode==GARAGE_MODE">Max shield: {{room.maxMaxSHIELD_CLASS}}</li>

                  <li ng-if="room.type==ENERGY_PROVIDER_CLASS && mode==GARAGE_MODE">Energy output: {{room.maxEnergySupply}}</li>
                  <li ng-if="room.type==ENERGY_PROVIDER_CLASS && mode==FIGHT_MODE && debug">Energy output:
                    <span ng-class="{damaged: room.damage < room.maxDamage}">
                      {{room.energySupply}}
                    </span>
                  </li>

                  <li ng-if="mode==GARAGE_MODE && room.upgrade">
                    <upgrade entity="room" ship="myShip" />
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li ng-if="mode==GARAGE_MODE && myShip.maxRooms > myShip.rooms.length">
            New rooms available:
            <ul ng-repeat="(title, cost) in myShip.newRoomCosts">
              <li>
                <a ng-if="myShip.haveEnoughResources(cost)" href="#" ng-click="myShip.buyRoom(title)">Buy {{title}}</a>
                {{cost}}
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <div class="span4">
      <h2 ng-if="mode==FIGHT_MODE">Enemy</h2>
      <div ng-if="mode==FIGHT_MODE" id="enemy">
        <ul>
          <li ng-if="debug">Free energy: {{enemy.freeEnergy}}</li>
          <li>Resources: {{ enemy.resources}}</li>
          <li>Level: {{ enemy.level}}</li>
          <li>Rooms:
            <ul ng-repeat="(roomId, room) in enemy.rooms">
              <li ng-switch on="room.type">{{room.title}}-{{roomId}}
                <ul>
                  <li>
                    <progress-bar complete="room.hp" total="room.maxHp"
                      color="red" text="Hp: {{room.hp}}/{{room.maxHp}}" />
                  </li>
                  <li ng-if="room.type==WEAPON_CLASS && debug && room.hp > 0">
                    <progress-bar complete="room.progress"
                      total="100" color="#CCCC00"
                      text="Next shot" />
                  </li>
                  <li ng-if="room.type==SHIELD_CLASS && debug && room.hp > 0">
                    <progress-bar complete="room.progress"
                      total="100" color="#CCCC00"
                      text="Next load" />
                  </li>
                  <li ng-if="room.type==SHIELD_CLASS && room.hp > 0">
                    <progress-bar complete="room.shield"
                      total="room.maxSHIELD_CLASS" color="#659EC7"
                      text="SHIELD_CLASS" />
                  </li>

                  <li ng-if="room.type==WEAPON_CLASS && debug">Energy: {{room.energy}}</li>
                  <li ng-if="room.type==WEAPON_CLASS && debug">Damage:
                    <span ng-class="{damaged: room.damage < room.maxDamage}">
                      {{room.damage}}
                    </span>
                  </li>
                  <li ng-if="room.type==WEAPON_CLASS && debug">Reload rate:
                    <span ng-class="{damaged: room.reloadRate < room.maxReloadRate}">
                      {{room.reloadRate}}
                    </span>
                  </li>
                  <li ng-if="room.type==WEAPON_CLASS && debug">Energy demand: {{room.energyDemand}}</li>
                  <li ng-if="room.type==WEAPON_CLASS">Targeting: {{myShip.rooms[room.targetId].title}}-{{room.targetId}}</li>

                  <li ng-if="room.type==SHIELD_CLASS && debug">Reload rate:
                    <span ng-class="{damaged: room.reloadRate < room.maxReloadRate}">
                      {{room.reloadRate}}
                    </span>
                  </li>
                  <li ng-if="room.type==SHIELD_CLASS && debug">Energy: {{room.energy}}</li>
                  <li ng-if="room.type==SHIELD_CLASS && debug">Energy demand: {{room.energyDemand}}</li>

                  <li ng-if="room.type==ENERGY_PROVIDER_CLASS && debug">Max energy output: {{room.maxEnergySupply}}</li>
                  <li ng-if="room.type==ENERGY_PROVIDER_CLASS && debug">Energy output:
                    <span ng-class="{damaged: room.damage < room.maxDamage}">
                      {{room.energySupply}}
                    </span>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    </div>
  </div>
</body>
</html>
